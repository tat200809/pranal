/*
 * ANTRL (http://www.antlr.org/) grammar for the project language. You will
 * probably want to adapt the file to generate parser for your language of
 * choice and use your own data structures (or define tree parser to traverse
 * the tree generated by ANTLR).
 *
 * Note that this has not been throughly tested, so let us know if there are
 * any problems.
 */
grammar MicroC;

@header {package microC.parsing;}

options {
  language= Java;  /* Change this to generate parser for some other language. */
}
  
  TRUE : 'true';
  FALSE : 'false';
  AND : '&';
  OR : '|';
  ASSIGN : '=';
  SEMI : ';';
  GT : '>';
  GE : '>=';
  LT : '<';
  LE : '<=';
  EQ : '==';
  NEQ : '!=';
  PLUS : '+';
  MINUS : '-';
  MUL : '*';
  DIV : '/';
  NOT : 'not';
  LPAREN : '(';
  RPAREN : ')';
  LBRACE : '{';
  RBRACE : '}';
  LBRACKET : '[';
  RBRACKET : ']';
  COLON : ':';
  IF : 'if';
  ELSE : 'else';
  WHILE : 'while';
  CONTINUE : 'continue';
  BREAK : 'break';
  WRITE : 'write';
  READ : 'read';
  INT : 'int';



aexpr : aexpr1 (PLUS aexpr1 | MINUS aexpr1)* ;

aexpr1 : aexpr2 (MUL aexpr2 | DIV aexpr2)* ;

aexpr2 : MINUS aexpr3
       | aexpr3
       ;

aexpr3 : IDENTIFIER (LBRACKET aexpr RBRACKET)?
       | INTEGER
       | LPAREN aexpr RPAREN
       ;

bexpr : bexpr1 (OR bexpr1)*
      ;

bexpr1 : bexpr2 (AND bexpr2)*
       ;

bexpr2 : aexpr opr aexpr
       | NOT bexpr
       | TRUE
       | FALSE
       | LPAREN bexpr RPAREN
       ;

opr : GT
    | GE
    | LT
    | LE
    | EQ
    | NEQ
    ;


basicDecl : INT identifier (LBRACKET integer RBRACKET)? SEMI ;

decl : basicDecl decl? ;


basicStmt : assignStmt
     | continueStmt
	 | breakStmt
     | readStmt
     | writeStmt
	 | ifelseStmt
     | whileStmt
	 | blockStmt
     ;
	 
stmt : basicStmt stmt? ;

assignStmt : identifier (LBRACKET aexpr RBRACKET)? ASSIGN aexpr SEMI ;

continueStmt : CONTINUE SEMI ;

readStmt : READ identifier (LBRACKET aexpr RBRACKET)? SEMI ;

breakStmt : BREAK SEMI ;

writeStmt : WRITE aexpr SEMI ;

ifelseStmt : IF LPAREN bexpr RPAREN  LBRACE stmt RBRACE (ELSE LBRACE stmt RBRACE)? ;


whileStmt : WHILE LPAREN bexpr RPAREN  LBRACE stmt RBRACE ;

blockStmt : LBRACE decl? stmt RBRACE ;

program :  LBRACE decl? stmt RBRACE ;


identifier : IDENTIFIER;

integer : INTEGER;

COMMENT : '/*' .*? '*/' -> channel(HIDDEN);
     

INTEGER : ('0' | '1'..'9' '0'..'9'*);

IDENTIFIER : LETTER (LETTER|'0'..'9')* ;

fragment
LETTER : 'A'..'Z'
       | 'a'..'z'
       | '_'
       ;

WS : (' '|'\r'|'\t'|'\u000C'|'\n') -> skip ;
